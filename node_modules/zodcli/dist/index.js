import { z, ZodArray, ZodDefault, } from "zod";
export const booleanArgument = z.union([
    z.literal("true").transform(() => true),
    z.literal("false").transform(() => false),
    z.null().transform(() => true),
]);
export const argumentParser = ({ options, aliases, }) => {
    return z.array(z.string()).transform((argv, ctx) => {
        const rawResults = {};
        const unknownKeys = [];
        for (let i = 0; i < argv.length; i++) {
            const arg = argv[i];
            let key;
            let value;
            if (arg.startsWith("-")) {
                if (arg.startsWith("--")) {
                    const parts = arg.slice("--".length).split("=", 2);
                    const kebabCaseKey = parts[0];
                    value = parts[1] ?? null;
                    if (kebabCaseKey.match(/[^a-z-]/)) {
                        // Unexpected non-lowercase characters in the argument name.
                        unknownKeys.push(arg);
                        continue;
                    }
                    key = kebabCaseKey.replace(/-(\w)/g, (_, firstLetter) => firstLetter.toUpperCase());
                }
                else if (arg.startsWith("-")) {
                    // Aliases
                    const parts = arg.slice("-".length).split("=", 2);
                    const alias = parts[0];
                    value = parts[1] ?? null;
                    if (alias.match(/[^a-z]/)) {
                        // Unexpected non-lowercase characters in the argument name.
                        unknownKeys.push(arg);
                        continue;
                    }
                    if (!(alias in aliases)) {
                        // No such alias.
                        unknownKeys.push(arg);
                        continue;
                    }
                    key = aliases[alias];
                }
                if (key.match(/[^a-zA-Z]/)) {
                    // Unexpected non-lowercase characters in the argument name.
                    unknownKeys.push(arg);
                    continue;
                }
                if (!(key in options.shape)) {
                    // No such argument.
                    unknownKeys.push(arg);
                    continue;
                }
                if (key in rawResults) {
                    rawResults[key].push(value);
                }
                else {
                    rawResults[key] = [value];
                }
            }
            else {
                // TODO: Positionals
                unknownKeys.push(arg);
                continue;
            }
        }
        if (unknownKeys.length > 0) {
            ctx.addIssue({
                code: z.ZodIssueCode.unrecognized_keys,
                keys: unknownKeys,
            });
        }
        const results = {};
        for (const key in rawResults) {
            let zodType = options.shape[key];
            if ("unwrap" in zodType) {
                zodType = zodType.unwrap();
            }
            if (zodType instanceof ZodDefault && "innerType" in zodType._def) {
                zodType = zodType._def.innerType;
            }
            const isSupposedToBeAnArray = zodType instanceof ZodArray;
            if (!isSupposedToBeAnArray && rawResults[key].length > 1) {
                ctx.addIssue({
                    code: z.ZodIssueCode.custom,
                    message: `Cannot parse argument: \`${key}\`. Unexpected multiple values: ${rawResults[key]
                        .map((value) => `\`${value}\``)
                        .join(", ")}.`,
                });
                continue;
            }
            else if (!isSupposedToBeAnArray) {
                results[key] = rawResults[key][0];
            }
            else {
                results[key] = rawResults[key];
            }
        }
        return options.parse(results);
    });
};
//# sourceMappingURL=index.js.map